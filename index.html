<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Resonance Puzzle - NO₂⁻ Game</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #020617 0%, #020617 45%, #000 100%);
      color: #e5e7eb;
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 16px;
    }
    .app {
      display: grid;
      grid-template-columns: minmax(260px, 320px) minmax(500px, 840px);
      gap: 16px;
      width: 100%;
      max-width: 1180px;
    }
    .panel {
      background: rgba(15, 23, 42, 0.96);
      border-radius: 18px;
      border: 1px solid rgba(148, 163, 184, 0.4);
      box-shadow: 0 20px 45px rgba(0,0,0,0.7);
      padding: 18px 18px 16px;
    }
    .panel-header { margin-bottom: 10px; }
    .title {
      font-size: 20px;
      font-weight: 700;
      letter-spacing: 0.03em;
      margin-bottom: 4px;
    }
    .subtitle { font-size: 13px; color: #9ca3af; }
    .badge-row {
      display: flex; flex-wrap: wrap; gap: 6px; margin-top: 10px;
    }
    .badge {
      font-size: 11px;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid rgba(96, 165, 250, 0.7);
      background: radial-gradient(circle at top, rgba(59,130,246,0.35), transparent);
      color: #bfdbfe;
      white-space: nowrap;
    }
    .section {
      margin-top: 12px;
      padding-top: 10px;
      border-top: 1px solid rgba(31,41,55,0.9);
    }
    .section-title {
      font-size: 13px;
      font-weight: 600;
      margin-bottom: 6px;
      color: #e5e7eb;
    }
    .section-body {
      font-size: 12px;
      color: #9ca3af;
      line-height: 1.5;
    }
    .tip-box {
      margin-top: 6px;
      padding: 8px 10px;
      border-radius: 10px;
      background: linear-gradient(135deg, rgba(34,197,94,0.12), rgba(37,99,235,0.12));
      border: 1px solid rgba(52,211,153,0.3);
      font-size: 12px;
      color: #bbf7d0;
    }
    .highlight { color: #bfdbfe; font-weight: 600; }

    /* Right side game */
    .game-header-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      margin-bottom: 10px;
      flex-wrap: wrap;
    }
    .game-title { font-size: 16px; font-weight: 600; }
    .game-subtitle { font-size: 12px; color: #9ca3af; }
    .pill {
      font-size: 11px;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(96,165,250,0.7);
      color: #bfdbfe;
      background: radial-gradient(circle at top, rgba(59,130,246,0.35), transparent);
      white-space: nowrap;
    }

    .puzzle-area {
      margin-top: 8px;
      border-radius: 14px;
      border: 1px solid rgba(55,65,81,0.9);
      background: radial-gradient(circle at center, #020617 0%, #020617 55%, #000 100%);
      padding: 14px 16px 16px;
      position: relative;
      min-height: 320px;
      overflow: hidden;
    }

    .board {
      position: relative;
      border-radius: 12px;
      border: 1px solid rgba(55,65,81,0.9);
      background: rgba(15,23,42,0.96);
      height: 210px;
      padding: 10px 16px;
      overflow: hidden;
    }
    .board-title {
      font-size: 12px;
      color: #9ca3af;
      margin-bottom: 4px;
    }
    .board-formula {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 26px;
      color: #e5e7eb;
      white-space: nowrap;
    }
    .board-formula sup { font-size: 14px; }

    .drop-zone {
      position: absolute;
      width: 40px;
      height: 40px;
      border-radius: 999px;
      border: 1.5px dashed rgba(96,165,250,0.8);
      background: radial-gradient(circle at center, rgba(30,64,175,0.32), transparent);
      box-shadow: 0 0 10px rgba(59,130,246,0.35);
    }
    .drop-zone.wrong {
      border-color: rgba(248,113,113,0.85);
      background: radial-gradient(circle at center, rgba(127,29,29,0.32), transparent);
      box-shadow: 0 0 10px rgba(248,113,113,0.4);
    }
    .drop-zone.highlight {
      box-shadow: 0 0 14px rgba(56,189,248,0.8);
    }

    .zone-leftO { top: 55%; left: 22%; transform: translate(-50%, -50%); }
    .zone-rightO { top: 55%; left: 78%; transform: translate(-50%, -50%); }
    .zone-wrongN { top: 28%; left: 50%; transform: translate(-50%, -50%); }

    .token-dock {
      margin-top: 12px;
      border-radius: 12px;
      border: 1px solid rgba(55,65,81,0.9);
      background: rgba(15,23,42,0.96);
      padding: 8px 10px;
      height: 80px;
    }
    .dock-label {
      font-size: 11px;
      color: #9ca3af;
      margin-bottom: 6px;
    }
    .tokens-row {
      position: relative;
      height: 52px;
    }
    .electron-token {
      width: 52px;
      height: 52px;
      border-radius: 999px;
      background: radial-gradient(circle at top, #e0f2fe, #0ea5e9);
      box-shadow: 0 0 12px rgba(56,189,248,0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      color: #0f172a;
      font-weight: 700;
      cursor: grab;
      user-select: none;
      touch-action: none;
      position: absolute;
    }
    .electron-token.dragging {
      cursor: grabbing;
      box-shadow: 0 0 18px rgba(56,189,248,1);
    }

    .message-row {
      margin-top: 10px;
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      font-size: 11px;
    }
    .btn {
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(75,85,99,0.9);
      background: rgba(31,41,55,0.96);
      color: #e5e7eb;
      font-size: 11px;
      cursor: pointer;
    }
    .btn:hover {
      background: rgba(37,99,235,0.9);
      border-color: rgba(96,165,250,1);
    }

    .status-bar-row {
      margin-top: 6px;
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 11px;
    }
    .bar-container {
      flex: 1;
      min-width: 140px;
      background: rgba(15,23,42,0.95);
      border-radius: 999px;
      overflow: hidden;
      border: 1px solid rgba(55,65,81,0.9);
      height: 14px;
    }
    .bar-fill {
      height: 100%;
      background: linear-gradient(90deg, #22c55e, #eab308, #ef4444);
      width: 100%;
      transform-origin: left center;
    }
    .status-text { color: #9ca3af; white-space: nowrap; }

    @media (max-width: 900px) {
      .app { grid-template-columns: 1fr; }
    }
    @media (max-width: 600px) {
      .board-formula { font-size: 22px; }
      .electron-token { width: 46px; height: 46px; font-size: 16px; }
    }
  </style>
</head>
<body>
<div class="app">
  <!-- Left panel: explanations -->
  <aside class="panel">
    <div class="panel-header">
      <div class="title">Resonance Puzzle</div>
      <div class="subtitle">
        Drag electron pairs to the correct resonance positions in NO₂⁻.
      </div>
      <div class="badge-row">
        <div class="badge">Topic: Resonance Structure</div>
        <div class="badge">Delocalised electrons · π bond · Formal charge</div>
      </div>
    </div>

    <div class="section">
      <div class="section-title">Current Goal</div>
      <div class="tip-box">
        Place both electron pairs in positions that represent valid resonance structures of
        <span class="highlight">NO₂⁻</span>.  
        In reality, the π bond and negative charge are <strong>delocalised</strong> between the two oxygen atoms.
      </div>
    </div>

    <div class="section">
      <div class="section-title">Learning Outcomes</div>
      <div class="section-body">
        • Resonance changes the positions of <strong>electrons</strong>, not the positions of atoms.<br/>
        • In NO₂⁻, the negative charge and π bond are <strong>delocalised</strong> and shared between the two oxygen atoms.<br/>
        • Resonance makes the overall molecule more <strong>stable</strong> than any single Lewis structure.
      </div>
    </div>

    <div class="section">
      <div class="section-title">How to Play</div>
      <div class="section-body">
        • On computer: use the mouse to <strong>click and drag</strong> the electron pairs into the circles.<br/>
        • On mobile: <strong>touch and drag</strong> the electron pairs with your finger.<br/>
        • After placing both electron pairs, press <span class="highlight">Check answer</span> to evaluate your structure.<br/>
        • If both electron pairs are in the correct O positions → valid resonance structure ✅<br/>
        • If electrons are placed on N or in the wrong positions → resonance stability decreases ❌
      </div>
    </div>
  </aside>

  <!-- Right panel: game -->
  <main class="panel">
    <div class="game-header-row">
      <div>
        <div class="game-title">NO₂⁻ Resonance Puzzle</div>
        <div class="game-subtitle">
          Represent how the π bond / negative charge can be shared over both oxygens.
        </div>
      </div>
      <div class="pill">Resonance · Interactive Puzzle</div>
    </div>

    <div id="puzzleArea" class="puzzle-area">
      <div class="board">
        <div class="board-title">One Lewis structure of NO₂⁻</div>
        <div class="board-formula">
          O = N – O<sup>−</sup>
        </div>

        <!-- Correct targets: both O atoms -->
        <div class="drop-zone zone-leftO" data-zone-id="leftO" data-correct="true"></div>
        <div class="drop-zone zone-rightO" data-zone-id="rightO" data-correct="true"></div>

        <!-- Incorrect target: above N -->
        <div class="drop-zone zone-wrongN wrong" data-zone-id="wrongN" data-correct="false"></div>
      </div>

      <div class="token-dock" id="tokenDock">
        <div class="dock-label">
          Drag these electron pairs into valid resonance positions (places where a π bond / lone pair can be delocalised):
        </div>
        <div class="tokens-row">
          <div class="electron-token" data-token-id="t1">··</div>
          <div class="electron-token" data-token-id="t2">··</div>
        </div>
      </div>

      <div class="message-row">
        <button class="btn" id="checkBtn">Check answer</button>
        <button class="btn" id="resetBtn">Reset</button>
        <span id="messageText">Place both electron pairs, then click "Check answer".</span>
      </div>

      <div class="status-bar-row">
        <div class="bar-container">
          <div id="stabilityBar" class="bar-fill"></div>
        </div>
        <div id="statusText" class="status-text">Resonance stability: 100%</div>
      </div>
    </div>
  </main>
</div>

<script>
  const puzzleArea   = document.getElementById("puzzleArea");
  const tokenElements = Array.from(document.querySelectorAll(".electron-token"));
  const zoneElements  = Array.from(document.querySelectorAll(".drop-zone"));
  const checkBtn      = document.getElementById("checkBtn");
  const resetBtn      = document.getElementById("resetBtn");
  const messageText   = document.getElementById("messageText");
  const stabilityBar  = document.getElementById("stabilityBar");
  const statusText    = document.getElementById("statusText");

  const tokensState   = {};   // tokenId -> { homeLeft, homeTop, assignedZoneId }
  const zoneOccupants = {};   // zoneId  -> tokenId | null
  let stability = 100;
  let gameOver  = false;

  let draggingToken = null;
  let dragOffsetX   = 0;
  let dragOffsetY   = 0;

  function getEventPos(e) {
    if (e.touches && e.touches.length > 0) {
      return { x: e.touches[0].clientX, y: e.touches[0].clientY };
    } else {
      return { x: e.clientX, y: e.clientY };
    }
  }

  // Move tokens into puzzleArea and record home positions relative to puzzleArea
  function initPositions() {
    const puzzleRect = puzzleArea.getBoundingClientRect();

    tokenElements.forEach((token) => {
      const rect = token.getBoundingClientRect();
      const tokenId = token.dataset.tokenId;
      const homeLeft = rect.left - puzzleRect.left;
      const homeTop  = rect.top  - puzzleRect.top;

      // Attach token directly to puzzleArea
      puzzleArea.appendChild(token);

      token.style.position = "absolute";
      token.style.left = homeLeft + "px";
      token.style.top  = homeTop  + "px";

      tokensState[tokenId] = {
        homeLeft,
        homeTop,
        assignedZoneId: null,
      };
    });

    zoneElements.forEach((zone) => {
      const zoneId = zone.dataset.zoneId;
      zoneOccupants[zoneId] = null;
    });
  }

  function onTokenDown(e) {
    if (gameOver) return;
    const token = e.currentTarget;
    draggingToken = token;
    token.classList.add("dragging");

    const pos  = getEventPos(e);
    const rect = token.getBoundingClientRect();
    dragOffsetX = pos.x - rect.left;
    dragOffsetY = pos.y - rect.top;

    document.addEventListener("mousemove", onMove);
    document.addEventListener("mouseup", onUp);
    document.addEventListener("touchmove", onMove, { passive: false });
    document.addEventListener("touchend", onUp);
    document.addEventListener("touchcancel", onUp);

    e.preventDefault();
  }

  function onMove(e) {
    if (!draggingToken) return;
    const pos = getEventPos(e);
    const puzzleRect = puzzleArea.getBoundingClientRect();

    let newLeft = pos.x - puzzleRect.left - dragOffsetX;
    let newTop  = pos.y - puzzleRect.top  - dragOffsetY;

    const maxLeft = puzzleRect.width  - draggingToken.offsetWidth;
    const maxTop  = puzzleRect.height - draggingToken.offsetHeight;
    if (newLeft < 0) newLeft = 0;
    if (newTop  < 0) newTop  = 0;
    if (newLeft > maxLeft) newLeft = maxLeft;
    if (newTop  > maxTop)  newTop  = maxTop;

    draggingToken.style.left = newLeft + "px";
    draggingToken.style.top  = newTop  + "px";

    zoneElements.forEach((z) => z.classList.remove("highlight"));
    const nearest = findNearestZone(draggingToken);
    if (nearest && nearest.distance < 70) {
      nearest.zone.classList.add("highlight");
    }

    e.preventDefault();
  }

  function onUp(e) {
    if (!draggingToken) return;

    zoneElements.forEach((z) => z.classList.remove("highlight"));

    const token = draggingToken;
    draggingToken = null;

    const tokenId = token.dataset.tokenId;
    const nearest = findNearestZone(token);
    if (nearest && nearest.distance < 70) {
      snapTokenToZone(token, nearest.zone);
    } else {
      resetTokenToHome(tokenId);
    }

    document.removeEventListener("mousemove", onMove);
    document.removeEventListener("mouseup", onUp);
    document.removeEventListener("touchmove", onMove);
    document.removeEventListener("touchend", onUp);
    document.removeEventListener("touchcancel", onUp);

    token.classList.remove("dragging");
    e.preventDefault();
  }

  function findNearestZone(token) {
    const puzzleRect = puzzleArea.getBoundingClientRect();
    const rect = token.getBoundingClientRect();
    const tx = rect.left - puzzleRect.left + rect.width / 2;
    const ty = rect.top  - puzzleRect.top  + rect.height / 2;

    let best = null;
    zoneElements.forEach((zone) => {
      const zr = zone.getBoundingClientRect();
      const zx = zr.left - puzzleRect.left + zr.width / 2;
      const zy = zr.top  - puzzleRect.top  + zr.height / 2;
      const dx = tx - zx;
      const dy = ty - zy;
      const dist = Math.hypot(dx, dy);
      if (!best || dist < best.distance) best = { zone, distance: dist };
    });
    return best;
  }

  function snapTokenToZone(token, zone) {
    const tokenId = token.dataset.tokenId;
    const zoneId  = zone.dataset.zoneId;

    const prevZoneId = tokensState[tokenId].assignedZoneId;
    if (prevZoneId && zoneOccupants[prevZoneId] === tokenId) {
      zoneOccupants[prevZoneId] = null;
    }

    const currentOccupant = zoneOccupants[zoneId];
    if (currentOccupant && currentOccupant !== tokenId) {
      resetTokenToHome(currentOccupant);
    }

    const puzzleRect = puzzleArea.getBoundingClientRect();
    const zr = zone.getBoundingClientRect();
    const left = zr.left - puzzleRect.left + zr.width / 2 - token.offsetWidth / 2;
    const top  = zr.top  - puzzleRect.top  + zr.height / 2 - token.offsetHeight / 2;

    token.style.left = left + "px";
    token.style.top  = top  + "px";

    tokensState[tokenId].assignedZoneId = zoneId;
    zoneOccupants[zoneId] = tokenId;
  }

  function resetTokenToHome(tokenId) {
    const token = tokenElements.find((t) => t.dataset.tokenId === tokenId);
    if (!token) return;
    const state = tokensState[tokenId];
    token.style.left = state.homeLeft + "px";
    token.style.top  = state.homeTop  + "px";

    if (state.assignedZoneId && zoneOccupants[state.assignedZoneId] === tokenId) {
      zoneOccupants[state.assignedZoneId] = null;
    }
    state.assignedZoneId = null;
  }

  function updateStabilityBar() {
    const ratio = Math.max(0, stability) / 100;
    stabilityBar.style.transform = `scaleX(${ratio})`;
    statusText.textContent = `Resonance stability: ${Math.max(0, Math.round(stability))}%`;
  }

  function checkAnswer() {
    if (gameOver) return;

    const allPlaced = tokenElements.every(
      (t) => tokensState[t.dataset.tokenId].assignedZoneId !== null
    );
    if (!allPlaced) {
      messageText.textContent = "Place both electron pairs onto the circles first.";
      return;
    }

    let allCorrect = true;

    tokenElements.forEach((t) => {
      const tokenId = t.dataset.tokenId;
      const zoneId  = tokensState[tokenId].assignedZoneId;
      const zone    = zoneElements.find((z) => z.dataset.zoneId === zoneId);
      if (!zone || zone.dataset.correct !== "true") allCorrect = false;
    });

    zoneElements.forEach((z) => {
      if (z.dataset.correct === "true" && !zoneOccupants[z.dataset.zoneId]) {
        allCorrect = false;
      }
    });

    if (allCorrect) {
      messageText.textContent =
        "Nice! Both oxygens now share the π bond / negative charge. This represents resonance in NO₂⁻.";
    } else {
      stability -= 30;
      if (stability <= 0) {
        stability = 0;
        gameOver = true;
        messageText.textContent =
          "This arrangement is not a valid resonance picture and the stability dropped to zero. Press Reset to try again.";
      } else {
        messageText.textContent =
          "Not quite. This does not match valid resonance structures. Adjust the electron pairs and try again.";
      }
      updateStabilityBar();
    }
  }

  function resetGame() {
    stability = 100;
    gameOver  = false;
    tokenElements.forEach((t) => resetTokenToHome(t.dataset.tokenId));
    messageText.textContent = 'Place both electron pairs, then click "Check answer".';
    updateStabilityBar();
  }

  function setup() {
    initPositions();
    tokenElements.forEach((token) => {
      token.addEventListener("mousedown", onTokenDown);
      token.addEventListener("touchstart", onTokenDown, { passive: false });
    });
    checkBtn.addEventListener("click", checkAnswer);
    resetBtn.addEventListener("click", resetGame);
    window.addEventListener("keydown", (e) => {
      if (e.key.toLowerCase() === "r") resetGame();
    });
    updateStabilityBar();
  }

  window.addEventListener("load", setup);
</script>
</body>
</html>
